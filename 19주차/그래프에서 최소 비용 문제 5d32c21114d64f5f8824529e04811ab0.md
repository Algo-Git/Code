# 그래프에서 최소 비용 문제

개념/문제: 개념
문제유형: 그래프, 최단거리
작성일시: December 2, 2021 7:42 PM

# 목차

- [그래프에서 최소 비용 문제]()
1. [최소 신장 트리]()
    - [Kruskal]()
    - [Prim]()
2. 최단 경로
2.1) 하나의 정점 → 끝 정점
    - [다익스트라]()
    - 벨만 포드
    
    2.2) 모든 정점간의 최단 경로
    
    - 플로이드 와샬
- Union-find

# 그래프에서 최소 비용 문제

---

<aside>
1️⃣ 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리 찾기
= 최소 신장 트리(MST)
⇒ KRUSKAL(간선 적을 때), PRIM(간선 많을 때)

</aside>

<aside>
2️⃣ 두 정점 사이의 최소 비용의 경로 찾기 
= 최단 경로

- 하나의 시작 정점에서 끝 정점까지의 최단 경로
⇒ 다익스트라(음의 가중치 x), 벨만 포드(음의 가중치 o)
- 모든 정점들에 대한 최단 경로
⇒ 플로이드 와샬
</aside>

# 최소 신장 트리

---

## Kruskal 알고리즘

> 간선을 하나씩 선택해서 MST를 찾는 알고리즘
> 
1. 모든 간선을 가중치에 따라 **오름차순**으로 정렬 (최초 한번)
2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
*** 사이클을 형성하는 간선은 선택 x!**
⇒ **union-find** 알고리즘을 이용한다.
3. n-1 개의 간선이 선택될 때까지 반복해서 선택

https://www.notion.so/ecdabf733d1b460da3729293a9b0595d#5d32c21114d64f5f8824529e04811ab0
![[https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html](https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html)](%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%205d32c21114d64f5f8824529e04811ab0/Untitled.png)

[https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html](https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html)

- 사이클을 형성하는 방법 ⇒ union-find
추가하고자하는 간선의 양끝 정점이 같이 집합에 속해있는지 검사
⇒ 즉, 코드로 구현할 때는 간선을 선택할 때마다 **union-find**에서 부모를 연결해준다.

## PRIM 알고리즘

> 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
> 
1. 임의의 정점을 하나 선택해서 시작
2. 선택한 정점과 인접하는 정점들 중에 최소 비용의 간선이 존재하는 정점 선택

![[https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html](https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html)](%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%205d32c21114d64f5f8824529e04811ab0/Untitled%201.png)

[https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html](https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html)

# 최단경로 - 하나의 정점 ⇒ 끝 정점

---

## 다익스트라 알고리즘

> 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
> 
- 탐욕 기법을 사용한 알고리즘. MST의 프림 알고리즘과 유사하다.

예를 들어 문제에서는 A→ B 최소 거리를 구하라고 한다면,

1. 정점개수만큼의 길이의 배열을 만든다 int[] d. 
초기화는 매우 큰 수로, 시작점은 0 초기화(d[A] = 0) 으로.
2. 방문하지 않았고(고려하지 않았고), d값이 최소인 곳을 경유지(k)로 정한다.
    1. k를 방문했다고(고려했다고) 체크해준다.
    2. **경유지를 거쳐서 갈 수 있는 곳(i)**은 d[i]와 d[k]+(k와 i를 잇는 간선 길이)를 비교해보고 더 작은 값으로 d[i]를 업데이트 한다. 
    - A ⇒ k ⇒ i 와 A ⇒ (고려한 경유지 중 최적 경로) ⇒ i 중 더 작은 값으로 업데이트
3. 경유지(k) == 목적지 (B) 이면 끝낸다.
    - 끝내지 않고 모든 경유지를 다 고려하면 끝난다는 조건 하에 실행한다면, A에서 모든 곳으로 가는 최소 비용을 구할 수 있다.

### [백준 2056][골드4] 작업

## 위상 정렬

문제에서 선행관계 → 위상정렬!

개념 : 나에게 향하는 화살표의 개수가 0개이면 작업을 실행한다.

### [백준 15685][골드4] 드래곤 커브

![B8D836CB-04CC-42D6-91FA-31A20C75FD5F.jpeg](%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%205d32c21114d64f5f8824529e04811ab0/B8D836CB-04CC-42D6-91FA-31A20C75FD5F.jpeg)
